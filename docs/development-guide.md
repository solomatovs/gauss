# Gauss — Руководство по разработке

## Принципы

### 1. Никаких panic и unwrap в неожиданных местах

Процесс должен быть полностью подконтрольным. Все ошибки обрабатываются через `Result` и типизированные ошибки (`EngineError`, `PluginError`). Запрещены:

- `unwrap()`, `expect()` в production-коде (допускается только в тестах)
- `panic!()` вне случаев, когда это явный инвариант, который не может быть нарушен
- неявные паники через индексацию (`vec[i]`) — использовать `.get()` с обработкой

Любая ошибка должна подниматься наверх и логироваться, а не ронять процесс.

#### Архитектура ошибок

Система ошибок двухуровневая — плагинный слой и слой движка:

```
Плагин (.so)                    Движок (gauss-engine)          main()
        │                              │                          │
   PluginError ──────────────► EngineError ──────────────► tracing::error / exit
   (gauss-api)                   (#[from] PluginError)
```

**`PluginError`** (`gauss-api/src/error.rs`) — единый тип ошибки для всех плагинных трейтов (`TopicStorage`, `Processor`, `FormatSerializer`, `FieldConverter`). Содержит `ErrorKind` + сообщение:

| ErrorKind | Когда использовать |
|-----------|-------------------|
| `Config` | Невалидный конфиг плагина, отсутствующие поля |
| `Io` | Файловые, сетевые, системные ошибки |
| `Format` | Ошибка сериализации/десериализации данных |
| `Schema` | Несовместимость схем, отсутствие полей |
| `Logic` | Нарушение инварианта внутри плагина (не инициализирован и т.п.) |

**`EngineError`** (`gauss-engine/src/error.rs`) — ошибки оркестрации. Оборачивает `PluginError` через `#[from]` для прозрачного проброса. Собственные варианты: `Config`, `TopicNotFound`, `UnsupportedReadMode`, `Io`.

**FFI-граница** — плагины, загруженные как .so, не могут возвращать Rust типы напрямую. Ошибка передаётся через `PluginCreateResult { plugin_ptr, error_ptr, error_len }`. Хост извлекает сообщение, освобождает память и конструирует `EngineError`.

**Автоматические конверсии** — `PluginError` реализует `From` для стандартных типов ошибок, что позволяет использовать `?` без `.map_err()`:

| `From<T>` | → `ErrorKind` | Пример |
|-----------|---------------|--------|
| `std::io::Error` | `Io` | `File::open(path)?` |
| `serde_json::Error` | `Format` | `serde_json::from_str(s)?` |
| `std::str::Utf8Error` | `Format` | `std::str::from_utf8(bytes)?` |
| `std::string::FromUtf8Error` | `Format` | `String::from_utf8(vec)?` |

**Правила:**

- Плагины возвращают `Result<_, PluginError>` — никогда не паникуют
- Движок конвертирует `PluginError` → `EngineError` автоматически через `?`
- `main()` логирует финальную ошибку и завершает процесс с ненулевым кодом
- **Никаких `Result<_, String>`** — всегда типизированные ошибки (`PluginError`, `EngineError`). Строковые ошибки не дают вызывающему коду возможности различать категории и принимать решения (retry, skip, fail)
- **Никаких `From<String>` / `From<&str>`** для типов ошибок — конверсия из голой строки скрывает категорию. Используйте явные конструкторы: `PluginError::config("...")`, `PluginError::io("...")`
- **Каждый уровень — свой тип** — плагины используют `PluginError`, движок — `EngineError`. Не пробрасывайте чужой тип ошибки напрямую, оборачивайте через `#[from]` или явный вариант enum
- **Добавляйте контекст при пересечении границ** — при вызове `?` через границу (плагин → движок, хелпер → оркестратор) используйте `.map_err(|e| e.with_context("что именно делали"))`. Метод `.with_context()` есть на обоих типах — он дописывает контекст к сообщению, сохраняя `ErrorKind`. Без контекста ошибка `"Io: permission denied"` не даёт понять, где она произошла; с контекстом — `"topic 'input': Io: permission denied"`

### 2. Полностью плагинная архитектура — без builtin-плагинов

Центральный API (`gauss-api`) определяет абстрактные трейты: `TopicStorage`, `Processor`, `FormatSerializer`, `FieldConverter`. Весь конкретный функционал живёт в плагинах, которые реализуют эти трейты.

- Ядро (`gauss-engine`) не содержит бизнес-логики — только оркестрация
- Любой плагин можно заменить на другой с тем же трейтом без изменения ядра
- Плагины изолированы друг от друга и взаимодействуют только через API трейты
- **Нет builtin-плагинов** — движок не зависит ни от одного плагинного крейта напрямую. Все плагины загружаются как `.so` через FFI (`dlopen`/`dlsym`). В конфиге указываются пути к `.so` файлам, не строковые алиасы:

```toml
# Правильно — путь к .so:
storage = "./plugins/libgauss_storage_memory.so"
plugin = "./plugins/libgauss_processor_passthrough.so"

# Неправильно — нет builtin алиасов:
# storage = "memory"
# plugin = "builtin:passthrough"
```

- Плагинные крейты используют `crate-type = ["rlib", "cdylib"]` — `cdylib` для .so загрузки движком, `rlib` для собственных unit/integration тестов

### 3. ABI-версионирование плагинов

Каждый плагин (.so) экспортирует функцию проверки ABI-версии. При загрузке хост проверяет совместимость. Несовместимый плагин не загружается, а возвращает понятную ошибку.

- Версия ABI определяется в `gauss-api` и инкрементируется при breaking changes трейтов
- Плагин экспортирует `gauss_abi_version() -> u32`
- Хост проверяет: `plugin_abi == host_abi`, иначе отказ с сообщением о несовместимости

### 4. Полностью статическая компиляция

Все итоговые бинарные файлы компилируются статически. Никаких зависимостей от glibc, libssl и прочих системных библиотек в runtime.

- Target: `x86_64-unknown-linux-musl` (или аналогичный static target)
- TLS: `rustls` вместо OpenSSL
- Итоговый контейнер может быть `FROM scratch` или `FROM alpine` без дополнительных пакетов

### 5. Тесты в отдельной директории

Тесты не пишутся inline (`#[cfg(test)] mod tests`) в файлах с кодом. Вместо этого каждый крейт имеет директорию `tests/` на уровне `src/`, где тесты организованы по файлам:

```
my-crate/
├── Cargo.toml
├── src/
│   └── lib.rs
└── tests/
    ├── feature_a.rs
    └── feature_b.rs
```

Cargo автоматически компилирует каждый файл из `tests/` как отдельный integration test binary.
